---
title: "Say what you mean"
slug: "say-what-you-mean"
date: "2026-01-25"
heroImage: "./nancy-sluggo.webp"
---

As programmers, we're absolutely spoiled in the modern era. We have languages that are more expressive than ever, tools
to help us use them, and communities everywhere we can turn to for advice. So it comes as something of a surprise to see
so much of the data we use modeled using primitive times. Surely, we can do better, can't we?

Here's a little example:

```csharp
decimal oneBanana = 10.0m;  // it's one banana, Michael, what could it cost?
int bananas = 6;            // that's about how many you want in a bunch

var totalPrice = oneBanana * bananas;
```

Now listen, this is an intentionally simple example, but let's keep going with it. For example, `oneBanana` isn't just
any old decimal number. It's a money value. Money is more than just a number, it's also a currency. Moreover, it's not
even just a monetary value. It's a price. Different things are priced differently. And bananas aren't, [as Lucille Bluth
would have you believe][onebanana], typically priced individually.

Turning our attention to bananas, we now see that using an int is a little bit over simple, right? A proper calculation
would be $total\ price = (price\ per\ pound \cdot weight\ in\ pounds)$ but our minimal example doesn't capture that.

But what if it did? What if we could write:

```csharp
// Price by weight of $0.69/pound
var pricePerPound = Price.ByUnit(new Money(0.69m, Currency.USD), Unit.Pound);
// Weight of 1.2lb
var pounds = Weight.Pounds(1.2m);

// This works because pounds has the same unit as pricePerPound
var totalPrice = pricePerPound * pounds;

// This throws an exception because pricePerPound is incompatible with a weight in kilograms
var brokenExample = pricePerPound * Weight.Kilograms(1.0m);
```

I like the way this reads a lot better. We're no longer dealing with a bunch of nebulous `decimal` values, but instead
we've attached specific meaning to them. This code is also more expressive. It makes sense that you can multiply a price
per pound by pounds, because that's exactly what you would do in the real world. Your high school science teachers even
had a highfalutin word for it: dimensional analysis.

---

# Story time

My university had what I assume was a typical sequence of introductory classes: intro to programming, object-oriented
programming, and then data structures. The professor who taught data structures was a leading light in the [Ada
programming language community][ada]. Coincidentally, he wrote the _extremely required_ textbook. Funny how that worked
out.

In any case, one of Ada's more fascinating features is its support for subtypes. If a type should only be an integer
between `0` and `10`, by gum you can declare a type that accepts only those values. What's more, operators aren't
automatically assumed to be available just because they're available for the type they're based on. If you don't
explicitly say you can multiply `Pounds` by `Price`, then it can't be done.

As it happens, my professor's policy was that the basic types were strictly _verboten_. I know more than one fellow
student who risked failing the class for no reason other than failing to define subtypes.

---

If this all feels a little bit like the concept of Domain-Driven Design's [value objects][valueobjects] that's because
this is precisely what I'm driving at. This is part and parcel with DDD's conception of ubiquitous lanuage. We use the
problem domain's language, or to put it more bluntly, our _customers_' language.

Designing little structs for every kind of value you might ever encounter sounds like a lot of work, and a lot of
ceremony to create something that's often just primitive values with extra steps. But a few things happen the more you
do this.

1. **You get faster at it.** After you've built your first few of these guys, you'll realize that they don't have that
   much in them, really. They usually wrap a small number of values. You might define some operators, possibly
   conversions. You'll almost certainly want `IEquatable` and friends. But that's really it. They usually clock in
   around 50-ish lines at most.
2. **It makes _you_ faster.** What you're creating, in a sense, is a language-within-a-language. Your value objects form
   a kind of [DSL][dsl], even though you're still using C# syntax. You can test your types, and create tests for all
   kinds of valid and invalid scenarios. Beyond the functional benefits, tests create a powerful form of documentation
   for your colleagues.
3. **You'll eventually have all the types you need.** At the start of a project, it feels like you're spending so much
   time just doing scaffolding, just _defining_ things. To be sure, it can be exhausting. But once you've covered the
   basics, you'll find yourself declaring a lot fewer value types because you already have a rich vocabulary.
4. **You'll want whoever's holding back discriminated unions in C# to step on nothing but LEGO bricks[^lego] for the
   rest of their lives.** I'm exaggerating, but only a little. The single biggest missing feature in C# is still
   discriminated unions. [F# has them][fsharpunions], so don't tell me we can't find a syntax that works for C# too! But
   seriously, you'll encounter so many scenarios where you know the entire universe of values is covered by a few cases,
   but the cases may need different data. That is _exactly_ what discriminated unions are for.

Look, life's too short to use only `int`s and `float`s or whatever. Live a little! [Life's a banquet and most poor
suckers are starving to death!][auntiemame] But in all seriousness, we've got all this stuff here, it'd be a shame not
to use it.

[onebanana]: https://youtu.be/Nl_Qyk9DSUw?si=81mA84AmE9iCoRdR
[ada]: https://ada-lang.io/
[valueobjects]: https://martinfowler.com/bliki/ValueObject.html
[dsl]: https://en.wikipedia.org/wiki/Domain-specific_language
[fsharpunions]: https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/discriminated-unions
[auntiemame]: https://youtu.be/LGdLNDu-H40?si=rYeeYosJMUW_wik6&t=126
[lego]:
  https://www.reddit.com/r/grammar/comments/s8g2x9/comment/htg0fqw/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button

[^lego]:
    The official ruling from the company is that the [plural of LEGO is LEGO][lego], apparently. I draw the line at
    using it only as an adjective, though.
